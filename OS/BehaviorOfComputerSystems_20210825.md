# 컴퓨터 시스템의 동작
컴퓨터 시스템으로 작업을 처리할 때는 다음 순서에 따라 동작한다.  
제어장치가 이 동작을 제어한다.

1. 입력장치로 정보를 입력받아 메모리에 저장한다.
2. 메모리에 저장한 정보를 프로그램 제어에 따라 인출하여 연산장치에서 처리한다.
3. 처리한 정보를 출력장치에 표시하거나 보조기억장치에 저장한다.

입력장치로 컴퓨터에 유입되는 정보는 명령어와 데이터로 분류한다. 명령어는 실행할 산술, 논리 연산의 동작을 명시하는 문장으로, 어떤 작업을 수행하는 명령어 집합이 프로그램이다.  
프로그램은 컴파일러 등을 이용하여 0과 1로 이진화된 기계 명령어로 변환해야 컴퓨터가 이해할 수 있다.

## 1. 명령어의 구조

명령어는 프로세서가 실행할 연산인 연산 부호와 명령어가 처리할 데이터, 데이터를 저장한 레지스터나 메모리 주소인 피연산자로 구성된다. 명령어는 프로세서에 따라 고정 길이나 가변 길이를 구성한다.  
연산 부호는 특별한 경우가 아니면 한 개이나 피연산자는 여러 개일 수 있다.

- 연산부호(OPcode) : 프로세서가 실행할 동작인 연산을 지정한다. 예를 들어, 산술 연산, 논리 연산, 시프트, 보수 등 연산을 정의한다.  
- 피연산자(operand) : 연산할 데이터 정보를 저장한다. 데이터는 레지스터나 메모리, 가상 기억장치, 입출력장치 등에 위치할 수 있다. 보통 데이터 자체보다는 데이터의 위치를 저장한다.

명령어는 실행 전에 메인 메모리에 저장하며, 한 번에 하나씩 프로세서에 순차적으로 전송하여 해석, 실행한다. 명령어는 피연산자를 여러 개 포함할 수도 있다. 피연산자 수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어 등으로 구분한다.

명령어에 피연산자의 위치를 명시하는 방법(직접 주소 또는 간접 주소)을 나타내는 모드 비트(mode bit) I를 추가하거나, 다음 명령어의 위치를 나타내는 주소를 추가할 수도 있다.  
피연산자에 데이터가 있는 레지스터나 메모리 주소를 지정하면 직접주소(direct address)라 하고, 데이터가 있는 레지스터나 메모리 주소 정보를 지정하면 간접 주소(indirect address)라고 한다.  
간접 주소는 데이터의 주소를 읽을 때 한 번, 데이터를 읽을 때 한 번 총 두 번 메모리를 참조한다.

## 2. 명령어의 실행

명령어는 다음 과정을 거쳐 실행한다.

1. 명령어 인출
2. 명령어 해석, 프로그램 카운터 변경
3. 피연산자 인출
4. 명령어 실행
5. 결과 저장
6. 다음 명령어로 이동

프로세서의 제어장치가 명령어를 실행한다. 프로세서는 명령어를 한 번에 하나씩 인출하고 해석하여 연산한다. 명령어를 인출하여 연산 완료한 시점까지를 인출 - 해석 - 실행 사이클 또는 인출 - 실행 사이클이라고 한다. 간단히 명령어 실행 사이클(명령어 실행 주기)이라고도 한다.

명령어 실행 사이클은 명령어의 인출과 실행을 반복하는데, 이는 가장 일반적인 명령어 사이클이다.  
메모리 간접 주소 지정 방법은 실행 사이클을 시작하기 앞서 그 데이터의 실제 주소를 기억장치에서 읽어 오는 간접 사이클을 사용하기도 한다. 그리고 인터럽트를 처리하려고 인터럽트 사이클을 사용하기도 한다.

### 2.1 인출 사이클

인출 사이클(fetch cycle)은 명령어 실행 사이클의 첫번째 단계이다. 인출 사이클은 메모리에서 명령어를 읽어 명령어 레지스터에 저장하고, 다음 명령어를 실행하려고 프로그램 카운터를 증가시킨다. 인출 사이클에 쇼요되는 시간을 명령어 인출 시간이라고 하는데, 이 사이클에서 시간에 따른 세부 동작은 다음과 같다.

1. PC -> MAR : PC에 저장된 주소를 프로세서 내부 버스를 이용하여 MAR에 전달한다.  
2. Memory(MAR) -> MBR : MAR에 저장된 주소에 해당하는 메모리 위치에서 명령어를 인출한 후 이 명령어를 MBR에 저장한다. 이 때 제어장치는 메모리에 저장된 내용을 읽도록 제어 신호를 발생시킨다.  
PC + 1 -> PC : 다음 명령어를 인출하려고 PC를 증가시킨다.  
3. MBR -> IR : MBR에 저장된 내용을 IR에 전달한다.
    - PC : 프로그램 카운터  
    - MAR : 메모리 주소 레지스터  
    - MBR : 메모리 버퍼 레지스터
    - IR : 명령어 레지스터

### 2.2 실행 사이클

실행 사이클(execution cycle)에서는 인출한 명령어를 해석하고 그 결과에 따라 제어 신호를 발생시켜 명령어를 실행한다. 이 단계에서 소비되는 시간을 실행 시간이라고 한다.

### 2.3 간접 사이클

직접 주소 지정 방법을 사용하는 실행 사이클은 명령어를 즉시 수행하지만, 간접 주소 지정 방법을 사용하는 실행 사이클은 명령어를 수행하기 전에 실제 데이터가 저장된 주기억장치의 주소인 유효 주소를 한 번 더 읽어 온다. 간접 사이클(indirect cycle)에서 시간에 따른 세부 동작은 다음과 같다.

1. IR(addr) -> MAR : IR에 저장된 명령어의 피연산자(주소부)를 MAR에 전달한다.
2. Memory(MAR) -> MBR : MAR에 저장된 주소에 해당하는 메모리 위치에서 데이터를 인출한 후 이 데이터를 MBR에 저장한다. 이 때 제어장치는 메모리에서 저장된 내용을 읽도록 제어 신호를 발생시킨다.
3. MBR -> IR(addr) : MBR에 저장된 내용을 IR에 전달한다.

### 2.4 인터럽트 사이클

인터럽트는 프로세서가 프로그램을 수행하는 동안 컴퓨터 시스템의 내부나 외부에서 발생하는 예기치 못한 사건을 의미한다. 프로세서는 실행 사이클을 완료한 후 인터럽트 요구가 있는지 검사한다. 인터럽트 요구가 없으면 다음 명령어를 인출하고, 인터럽트 요구가 있으면 현재 수행 중인 프로그램의 주소(프로그램 카운터) 값을 스택이나 메모리의 0번지와 같은 특정 장소에 저장한다. 그리고 프로그램 카운터에는 인터럽트 처리 루틴의 시작 주소를 저장해 두었다가 인터럽트 처리를 완료하면 중단된 프로그램으로 복귀하여 계속 수행한다. 인터럽트 사이클(interrupt cycle)의 세부 동작은 다음과 같다.

1. PC -> MBR : PC의 내용을 MBR에 저장한다.
2. IntRoutine_Address -> PC : 인터럽트 루틴 주소를 PC에 저장한다.  
Save_Address -> MAR : PC에 저장된 인터럽트 루틴 주소를 MAR에 저장한다.
3. MAR -> Memory(MAR) : MBR의 주소에 있는 내용을 지시된 메모리 셀로 이동한다.

## 3. 인터럽트 명령어

인터럽트는 현재 실행 중인 프로그램을 중단하고 다른 프로그램의 실행을 요구하는 명령어이다.  
시스템의 처리 효율을 향상시키며, 프로그램이 실행 순서를 바꿔 가면서 처리하여 다중 프로그래밍에 사용한다.

또 인터럽트는 컴퓨터에 설치된 입출력장치나 프로그램 등에서 프로세서로 보내는 하드웨어 신호이다.  
인터럽트를 받은 프로그램은 실행을 중단하고 다른 프로그램을 실행한다. 단일 프로세서의 컴퓨터는 명령어를 한 번에 한 개만 수행할 수 있지만, 인터럽트를 이용하면 중간에 다른 프로그램이나 명령어를 수행할 수 있다. 특히 인터럽트는 예상치 못한 사용자 입력, 갑작스런 정전, 컴퓨터 시스템에서 긴급 요청, 잘모소딘 명령어 수행, 입출력 작업 완료와 같은 상황을 시스템이 적절히 처리하는 데 필요하다.

컴퓨터는 인터럽트를 외부장치의 동작과 자신의 동작을 조정하는 수단으로 사용한다. 예를 들어, 다중 사용자 시스템에 키보드를 여러 개 연결하면 각 키보드에서 입력되는 문자를 구분하여 처리해야 한다. 여러 키보드에서 동일한 문자를 동시에 입력해도 데이터를 손실하지 않고 수행해야 하므로, 컴퓨터는 해당 문자를 언제 입력했는지 알아야 한다.

프린터도 마찬가지이다. 프린터가 문자를 출력할 준비가 되어야 컴퓨터가 프린터로 문자를 전송할 수 있다. 그러므로 프로세서는 연결된 각 입출력장치의 현재 상태를 파악하고 있어야 하는데, 이 상태를 나타내려면 1비트 이상으로 표현한 준비 비트 또는 상태 비트가 필요하다. 입출력장치가 새로운 입출력 연산을 수행하려고 하면, 프로세서는 먼저 폴링(polling)으로 각 장치의 상태 비트를 검사한다. 그런데 인터럽트 개념이 없으면 장치의 상태를 계속 점검해야 해서 프로세서가 다른 연산을 수행할 수 없으므로, 오버헤드가 증가하여 수행 시간이 낭비된다. 이 때 인터럽트를 사용하면 입출력장치가 준비 상태가 될 때까지 프로세서가 다른 작업을 수행할 수 있다. 즉, 입출력장치가 준비 상태가 되었을 때 프로세서에 인터럽트 신호를 보내면 된다.

제어 버스 중 이런 목적으로 사용하는 것이 바로 인터럽트 요청 회선(IRQ, Interrupt ReQuest line)이다. 인터럽트 요청 회선을 사용하면 키보드에서 입력이 발생했을 때만 프로세서에 통보하여 처리하므로, 프로세서가 이벤트 발생 여부를 일일이 감시하지 않아도 된다. 그리고 프로세서가 외부장치의 상태를 직접 점검할 필요가 없어 이 시간 동안 다른 연산을 수행하여 프로세서의 효율을 높일 수 있다.

인터럽트는 크게 인터럽트 요청과 인터럽트 서비스 루틴으로 구분할 수 있다. 인터럽트 요청 신호에 따라 수행하는 루틴이 인터럽트 처리 프로그램, 즉 인터럽트 서비스 루틴(interrupt service routine)이다.

인터럽트 요청 회선은 단일 회선과 다중 회선으로 연결할 수 있다.  
- 단일 회선 : 인터럽트 요청이 가능한 모든 장치를 공통의 단일 회선으로 프로세서에 연결하는 방법이다. 회선 하나에 장치를 여러 개 연결하여 인터럽트를 요청한 장치를 판별하는 기능이 필요하다.
- 다중 회선 : 모든 장치를 서로 다른 고유의 회선으로 프로세서와 연결하는 방법이다. 그러므로 인터럽트를 요청한 장치를 바로 판별할 수 있다.

인터럽트 요청 신호가 발생하면 대부분의 컴퓨터는 정보를 단일 명령어로 저장할 수 있으므로 실행 중인 프로그램을 메모리에 저장하고, 인터럽트 처리 프로그램으로 분기한다. 그리고 인터럽트 처리 프로그램을 완료하면 인터럽트를 발생시킨 프로그램에 제어를 돌려준다.

인터럽트는 서브루틴 호출과 매우 비슷하지만, 몇 가지 면에서 다르다. 보통 서브루틴은 자신을 호출한 프로그램이 요구한 기능을 수행하지만, 인터럽트 처리 프로그램은 인터럽트가 발생했을 때 실행 중인 프로그램과 관련이 없을 수도 있다. 그러므로 프로세서는 복귀하여 실행할 때 영향을 미치는 정보를 저장해야 한다. 특히 인터럽트가 발생할 때의 상태 코드(상태 워드)를 임시 기억장치에 저장해 두었다가 나중에 복귀했을 때 이를 다시 적재해야 한다. 그래야 원래 프로그램을 인터럽트의 영향을 받지 않고 다시 실행할 수 있다.