[목록](https://github.com/JungInBaek/TIL/blob/main/README.md)

# 상호배제 방법들

## 1. 데커의 알고리즘
네덜란드의 수학자 테오도루스 요제프 데커는 두 프로세스가 서로 통신하려고 공유 메모리를 사용하여 충돌 없이 단일 자원을 공유할 수 있도록 허용하는 데커의 알고리즘(Dekker's algorithm)을 개발했다.

데커의 알고리즘은 두 프로세스가 동시에 임계 영역에 진입하려고 시도하면 순서에 따라 오직 하나만 임계 영역에 들어가도록 허용한다. 데커의 알고리즘에서 각 프로세스는 플래그를 설정할 수 있고, 다른 프로세스를 확인한 후 플래그를 재설정할 수도 있다. 프로세스가 임계 영역에 진입하고 싶으면 플래그를 설정하고 차례를 기다린다. 즉, 임계 영역에 다른 프로세스가 이미 있으면 해당 프로세스를 종료할 때까지 while문에서 순환한다. 여기서는 임계 영역 진입, 두 프로세스간의 순서를 나타내는 turn 변수를 입력했다는 의미로 flag[0] 플래그와 flag[1] 플래그를 사용한다. 그런데 프로세스 2개가 동시에 임계 영역에 진입하도록 플래그를 설정하면 교착 상태가 발생할 수 있다.
다음 데커의 알고리즘을 이용한 것이다.
```c
//  프로세스가 공유하는 데이터 flag[] : 부울(boolean) 배열, turn : 정수
flag[0] = false;
flag[1] = false;
turn = 0;                        //  공유 변수, 0 또는 1

//  프로세스 P0:                 //  프로세스 P0의 임계 영역 진입 절차
flag[0] = true;                 //  P0의 임계 영역 진입 표시
while(flag[1] == true) {        //  P1의 임계 영역 진입 여부 확인
    if(turn == 1) {             //  P1이 진입할 차례가 되면
        flag[0] == false;       //  플래그를 재설정하여 P1에 진입 순서 양보
        while(turn == 1) {      //  turn을 바꿀 때까지 대기
            //  바쁜 대기
        }
        flag[0] = true;         //  P0이 임계 영역에 재진입 시도
    }
}
/* 임계 영역 */;
turn = 1;                       //  P1에 진입 순서 제공
flag[0] = false;                //  P0의 임계 영역 사용 완료 지정
/* 나머지 영역*/;                //  P0이 나머지 영역 수행

//  프로세스 P1
flag[1] = true;
while(flag[0] == true) {
    if(turn == 0) {
        flag[1] == false;
        while(turn == 0) {
            //  바쁜 대기
        }
        flag[1] = true;
    }
}
/* 임계 영역 */;
turn = 0;
flag[1] = false;
/* 나머지 영역 */;
```

다음은 상호배제 문제를 소프트웨어적으로 해결하는 데커의 알고리즘 특징이다.
- 특별한 하드웨어 명령문이 필요 없다.
- 임계 영역 바깥에서 수행 중인 프로세스가 다른 프로세스들이 임계 영역에 들어가려는 것을 막지 않는다.
- 임계 영역에 들어가기를 원하는 프로세서를 무한정 기다리게 하지 않는다.

## 2. TestAndSet(TAS, 테스) 명령어
메모리 영역의 값에 대해 검사와 수정을 원자적으로 수행할 수 있는 하드웨어 명령어 TestAndSet을 이용하여 간단한 방법으로 임계 영역 문제를 해결할 수 있다.
TestAndSet 명령어는 하드웨어에서 명령을 사용하므로 알고리즘이 간단하고, 하나의 메모리 사이클에서 수행하여 생산자, 소비자에서 예로 든 counter 공유 변수를 수정해서 발생하는 경쟁 상황을 해결할 수 있다. 이 알고리즘에는 기계 명령어가 2개 있다. 하나는 원자적 연산 명령어인 TestAndSet이고, 다른 하나는 TestAndSet에 지역변수 lock을 설정하는 명령어이다.

TansAndSet 명령어는 일부 시스템에서 원자 명령어의 하나로, 읽기와 쓰기 모두를 제공한다. 이 명령어는 해당 주소의 값을 읽고 새 값으로 교체하면서 해당 메모리 위치의 이전 값을 돌려준다.

```c
//  target을 검사하고, target 값을 true로 설정
boolean TestAndSet(boolean *target) {
    boolean temp = *target;     //  이전 값 기록
    *target = true;             //  true로 설정
    return temp;                //  값 반환
}
```
TestAndSet명령어

부울 변수 lock을 사용하여 프로세스가 임계 영역에 있으면 1로, 없으면 0으로 설정할 수 있다. 그러므로 기계가 TestAndSet 명령어를 지원할 때는 부울 변수 lock을 false로 초기화하여 상호배제를 구현할 수 있다.

```c
do
{
    while(TestAndSet(&lock))        //  lock을 검사하여 true이면 대기, false이면 임계 영역 진입
        ;                           //  아무것도 하지 않음
        //  임계 영역
    lock = false;                   //  다른 프로세스의 진입 허용 의미로 lock을 false로
        //  나머지 영역
} while(true);
```
lock을 사용한 상호배제

처음에는 lock을 false로 초기화했으므로 처음 실행한 프로세스는 첫 while문을 통과한다. 하지만 TestAndSet 명령어로 lock은 true가 되므로 다른 프로세스가 임계 영역을 실행하려고 해도 while문에서는 아무것도 못하고 대기하게 된다(상호배제 조건 만족). 임계 영역을 다 끝낸 프로세스는 lock을 다시 false로 되돌려서 다른 프로세스도 임계 영역을 실행할 수 있도록 하여 진행 조건을 만족한다. 이 때 프로세스 2개는 문제가 없지만, 여러 프로세스가 대기 중일 때 어떤 프로세스는 무한 대기 상태에 빠질 수 있으므로 한정 대기 조건을 만족한다고 볼 수는 없다.

기계가 TestAndSet 명령어를 지원하면 먼저 boolean wating을 공유 배열 waiting[0 ...... n-1]로 선언한다. 공유 부울 변수 lock은 모든 프로세스에 전역변수로 선언하고 모두 false로 초기화한다. 그런 다음 다음과 같이 선언하여 상호배제를 구현할 수 있다.

```c
boolean waiting[n];
boolean lock = false;
int j;         //   0 ...... n-1
boolean key;
```

```c
do                                      //  프로세스 P1의 진입 영역
{
    waiting[i] = true;
    key = true;
    while(waiting[i] && key)
        key = TestAndSet(&lock);
    waiting[i] = false;
        //  임계 영역
        //  탈출 영역
    j = (i + 1) % n;
    while((j != i && !waiting[j]))      //  대기 중인 프로세스를 찾음
        j = (j + 1) % n;
    if(j == i)                          //  대기 중인 프로세스가 없으면
        lock = false;                   //  다른 프로세스의 진입 허용
    else                                //  대기 프로세스가 있으면 다음 순서로 임계 영역에 진입
        waiting[j] = false;             //  Pj가 임계 영역에 진입할 수 있도록
        //  나머지 영역
} while(true);
```
TestAndSet 명령어를 이용한 상호배제

프로세스 P<sub>i</sub>의 진입 영역에서 waiting[i]가 true이므로 P<sub>i</sub>는 임계 영역에 진입을 시도한다. 처음에 lock을 false로 초기화했다. 그러므로 임계 영역에 들어가는 첫번째 프로세스는 TestAndSet으로 key가 false가 되어 while문을 통과하여 임계 영역을 진행한다. lock은 TestAndSet으로 true가 되므로 key는 계속 true이고, 다른 프로세스는 while문을 통과하지 못한다. 반대로 다른 프로세스가 임계 영역에 있으면 lock은 true가 되어 P<sub>i</sub>는 while(waiting[i] && key) ~ key = TestAndSet(&lock);를 순환할 것이다. P<sub>i</sub>가 임계 영역에 들어가면 waiting[i]는 false로 설정하고 임계 영역으로 진입한다. 여기서 TestAndSet 명령어로 false를 반환하면서 lock이 true로 설정된 것에 주목해야 한다.

P<sub>i</sub>가 임계 영역을 떠날 때는 대기 프로세스 중에서 다음으로 진입할 수 있는 프로세스를 선택해야 한다. 다음으로 차례가 높은 프로세스를 시작한 후 각 프로세스를 검사한다. waiting 배열을 i+1, i+2, ...... , n-1, 0 순서로 조사하여 waiting 값이 true인 첫 번째 프로세스가 임계 영역으로 진입할 다음 프로세스가 된다. waiting 값이 true인 프로세스가 없으면 lock을 해제하고, 다음 프로세스가 P<sub>j</sub>이면 임계 영역에 진입할 수 있도록 P<sub>i</sub>는 waiting[j]를 false로 변경한다.

이 명령어의 주요 기능은 임계 영역의 잠금과 프로세스 대기 상태를 이용하여 프로세스를 차단하는 것이다.

TestAndSet 명령어의 장점과 단점은 다음 표와 같다.

<table>
    <tr>
        <td>장점</td><td>사용자 수준에서 가능하다. <br>- 메인 메모리를 공유하는 다중 프로세서나 단일 프로세서에서 프로세스 수에 관계없이 적용할 수 있다. <br>- lock 변수 수에 상관없이 구현할 수 있다. <br>- 구현이 단순하고 확인이 용이하다. <br>- 다중 임계 영역을 지원한다.</td>
    </tr>
    <tr>
        <td>단점</td><td>● 바쁜 대기 발생 <br>- 프로세서 시간 소모가 크다. <br>- 대기 프로세스는 비생산적, 자원이 소모되는 대기 루프에 남는다. <br>● 기아 상태 발생 : 프로세스가 임계 영역을 떠날 때 프로세스 하나 이상을 대기하는 경우 가능하다. <br>● 교착 상태 발생 : 플래그는 우선순위가 낮은 프로세스가 재설정할 수 있지만, 우선순위가 높은 프로세스가 선점한다. 따라서 우선순위가 낮은 프로세스는 lock을 가지고, 우선순위가 높은 프로세스가 이것을 얻으려고 시도할 때 높은 우선순위 프로세스는 무한정 바쁜 대기가 될 것이다.</td>
    </tr>
</table>