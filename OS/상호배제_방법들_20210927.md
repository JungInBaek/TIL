[목록](https://github.com/JungInBaek/TIL/blob/main/README.md)

# 상호배제 방법들

## 1. 데커의 알고리즘
네덜란드의 수학자 테오도루스 요제프 데커는 두 프로세스가 서로 통신하려고 공유 메모리를 사용하여 충돌 없이 단일 자원을 공유할 수 있도록 허용하는 데커의 알고리즘(Dekker's algorithm)을 개발했다.

데커의 알고리즘은 두 프로세스가 동시에 임계 영역에 진입하려고 시도하면 순서에 따라 오직 하나만 임계 영역에 들어가도록 허용한다. 데커의 알고리즘에서 각 프로세스는 플래그를 설정할 수 있고, 다른 프로세스를 확인한 후 플래그를 재설정할 수도 있다. 프로세스가 임계 영역에 진입하고 싶으면 플래그를 설정하고 차례를 기다린다. 즉, 임계 영역에 다른 프로세스가 이미 있으면 해당 프로세스를 종료할 때까지 while문에서 순환한다. 여기서는 임계 영역 진입, 두 프로세스간의 순서를 나타내는 turn 변수를 입력했다는 의미로 flag[0] 플래그와 flag[1] 플래그를 사용한다. 그런데 프로세스 2개가 동시에 임계 영역에 진입하도록 플래그를 설정하면 교착 상태가 발생할 수 있다.
다음 데커의 알고리즘을 이용한 것이다.
```c
//  프로세스가 공유하는 데이터 flag[] : 부울(boolean) 배열, turn : 정수
flag[0] = false;
flag[1] = false;
turn = 0;                        //  공유 변수, 0 또는 1

//  프로세스 P0:                 //  프로세스 P0의 임계 영역 진입 절차
flag[0] = true;                 //  P0의 임계 영역 진입 표시
while(flag[1] == true) {        //  P1의 임계 영역 진입 여부 확인
    if(turn == 1) {             //  P1이 진입할 차례가 되면
        flag[0] == false;       //  플래그를 재설정하여 P1에 진입 순서 양보
        while(turn == 1) {      //  turn을 바꿀 때까지 대기
            //  바쁜 대기
        }
        flag[0] = true;         //  P0이 임계 영역에 재진입 시도
    }
}
/* 임계 영역 */;
turn = 1;                       //  P1에 진입 순서 제공
flag[0] = false;                //  P0의 임계 영역 사용 완료 지정
/* 나머지 영역*/;                //  P0이 나머지 영역 수행

//  프로세스 P1
flag[1] = true;
while(flag[0] == true) {
    if(turn == 0) {
        flag[1] == false;
        while(turn == 0) {
            //  바쁜 대기
        }
        flag[1] = true;
    }
}
/* 임계 영역 */;
turn = 0;
flag[1] = false;
/* 나머지 영역 */;
```

다음은 상호배제 문제를 소프트웨어적으로 해결하는 데커의 알고리즘 특징이다.
- 특별한 하드웨어 명령문이 필요 없다.
- 임계 영역 바깥에서 수행 중인 프로세스가 다른 프로세스들이 임계 영역에 들어가려는 것을 막지 않는다.
- 임계 영역에 들어가기를 원하는 프로세서를 무한정 기다리게 하지 않는다.

## 2. TestAndSet(TAS, 테스) 명령어
메모리 영역의 값에 대해 검사와 수정을 원자적으로 수행할 수 있는 하드웨어 명령어 TestAndSet을 이용하여 간단한 방법으로 임계 영역 문제를 해결할 수 있다.
TestAndSet 명령어는 하드웨어에서 명령을 사용하므로 알고리즘이 간단하고, 하나의 메모리 사이클에서 수행하여 생산자, 소비자에서 예로 든 counter 공유 변수를 수정해서 발생하는 경쟁 상황을 해결할 수 있다. 이 알고리즘에는 기계 명령어가 2개 있다. 하나는 원자적 연산 명령어인 TestAndSet이고, 다른 하나는 TestAndSet에 지역변수 lock을 설정하는 명령어이다.

TansAndSet 명령어는 일부 시스템에서 원자 명령어의 하나로, 읽기와 쓰기 모두를 제공한다. 이 명령어는 해당 주소의 값을 읽고 새 값으로 교체하면서 해당 메모리 위치의 이전 값을 돌려준다.

```c
//  target을 검사하고, target 값을 true로 설정
boolean TestAndSet(boolean *target) {
    boolean temp = *target;     //  이전 값 기록
    *target = true;             //  true로 설정
    return temp;                //  값 반환
}
```
TestAndSet명령어

부울 변수 lock을 사용하여 프로세스가 임계 영역에 있으면 1로, 없으면 0으로 설정할 수 있다. 그러므로 기계가 TestAndSet 명령어를 지원할 때는 부울 변수 lock을 false로 초기화하여 상호배제를 구현할 수 있다.

```c
do
{
    while(TestAndSet(&lock))        //  lock을 검사하여 true이면 대기, false이면 임계 영역 진입
        ;                           //  아무것도 하지 않음
        //  임계 영역
    lock = false;                   //  다른 프로세스의 진입 허용 의미로 lock을 false로
        //  나머지 영역
} while(true);
```
lock을 사용한 상호배제

처음에는 lock을 false로 초기화했으므로 처음 실행한 프로세스는 첫 while문을 통과한다. 하지만 TestAndSet 명령어로 lock은 true가 되므로 다른 프로세스가 임계 영역을 실행하려고 해도 while문에서는 아무것도 못하고 대기하게 된다(상호배제 조건 만족). 임계 영역을 다 끝낸 프로세스는 lock을 다시 false로 되돌려서 다른 프로세스도 임계 영역을 실행할 수 있도록 하여 진행 조건을 만족한다. 이 때 프로세스 2개는 문제가 없지만, 여러 프로세스가 대기 중일 때 어떤 프로세스는 무한 대기 상태에 빠질 수 있으므로 한정 대기 조건을 만족한다고 볼 수는 없다.

기계가 TestAndSet 명령어를 지원하면 먼저 boolean wating을 공유 배열 waiting[0 ...... n-1]로 선언한다. 공유 부울 변수 lock은 모든 프로세스에 전역변수로 선언하고 모두 false로 초기화한다. 그런 다음 다음과 같이 선언하여 상호배제를 구현할 수 있다.

```c
boolean waiting[n];
boolean lock = false;
int j;         //   0 ...... n-1
boolean key;
```

```c
do                                      //  프로세스 P1의 진입 영역
{
    waiting[i] = true;
    key = true;
    while(waiting[i] && key)
        key = TestAndSet(&lock);
    waiting[i] = false;
        //  임계 영역
        //  탈출 영역
    j = (i + 1) % n;
    while((j != i && !waiting[j]))      //  대기 중인 프로세스를 찾음
        j = (j + 1) % n;
    if(j == i)                          //  대기 중인 프로세스가 없으면
        lock = false;                   //  다른 프로세스의 진입 허용
    else                                //  대기 프로세스가 있으면 다음 순서로 임계 영역에 진입
        waiting[j] = false;             //  Pj가 임계 영역에 진입할 수 있도록
        //  나머지 영역
} while(true);
```
TestAndSet 명령어를 이용한 상호배제

프로세스 P<sub>i</sub>의 진입 영역에서 waiting[i]가 true이므로 P<sub>i</sub>는 임계 영역에 진입을 시도한다. 처음에 lock을 false로 초기화했다. 그러므로 임계 영역에 들어가는 첫번째 프로세스는 TestAndSet으로 key가 false가 되어 while문을 통과하여 임계 영역을 진행한다. lock은 TestAndSet으로 true가 되므로 key는 계속 true이고, 다른 프로세스는 while문을 통과하지 못한다. 반대로 다른 프로세스가 임계 영역에 있으면 lock은 true가 되어 P<sub>i</sub>는 while(waiting[i] && key) ~ key = TestAndSet(&lock);를 순환할 것이다. P<sub>i</sub>가 임계 영역에 들어가면 waiting[i]는 false로 설정하고 임계 영역으로 진입한다. 여기서 TestAndSet 명령어로 false를 반환하면서 lock이 true로 설정된 것에 주목해야 한다.

P<sub>i</sub>가 임계 영역을 떠날 때는 대기 프로세스 중에서 다음으로 진입할 수 있는 프로세스를 선택해야 한다. 다음으로 차례가 높은 프로세스를 시작한 후 각 프로세스를 검사한다. waiting 배열을 i+1, i+2, ...... , n-1, 0 순서로 조사하여 waiting 값이 true인 첫 번째 프로세스가 임계 영역으로 진입할 다음 프로세스가 된다. waiting 값이 true인 프로세스가 없으면 lock을 해제하고, 다음 프로세스가 P<sub>j</sub>이면 임계 영역에 진입할 수 있도록 P<sub>i</sub>는 waiting[j]를 false로 변경한다.

이 명령어의 주요 기능은 임계 영역의 잠금과 프로세스 대기 상태를 이용하여 프로세스를 차단하는 것이다.

TestAndSet 명령어의 장점과 단점은 다음 표와 같다.

<table>
    <tr>
        <td>장점</td><td>사용자 수준에서 가능하다. <br>- 메인 메모리를 공유하는 다중 프로세서나 단일 프로세서에서 프로세스 수에 관계없이 적용할 수 있다. <br>- lock 변수 수에 상관없이 구현할 수 있다. <br>- 구현이 단순하고 확인이 용이하다. <br>- 다중 임계 영역을 지원한다.</td>
    </tr>
    <tr>
        <td>단점</td><td>● 바쁜 대기 발생 <br>- 프로세서 시간 소모가 크다. <br>- 대기 프로세스는 비생산적, 자원이 소모되는 대기 루프에 남는다. <br>● 기아 상태 발생 : 프로세스가 임계 영역을 떠날 때 프로세스 하나 이상을 대기하는 경우 가능하다. <br>● 교착 상태 발생 : 플래그는 우선순위가 낮은 프로세스가 재설정할 수 있지만, 우선순위가 높은 프로세스가 선점한다. 따라서 우선순위가 낮은 프로세스는 lock을 가지고, 우선순위가 높은 프로세스가 이것을 얻으려고 시도할 때 높은 우선순위 프로세스는 무한정 바쁜 대기가 될 것이다.</td>
    </tr>
</table>

## 3. 세마포
앞서 제시한 상호배제의 해결 방법은 좀 더 복잡한 문제에서는 일반화하기가 어렵다. 또 프로세스가 임계 영역에 진입할 수 없을 때는 바쁜 대기를 하게 되어 프로세스를 낭비한다. 진입 조건을 반복 조사하지 않고 true일 때 프로세스 상태를 확인한다면 프로세서 사이클을 낭비하지 않을 것이다. 다익스트라는 1965년 새로운 동기화 도구인 세마포(semaphore)를 제안하여 이 문제를 해결했다. 세마포는 상호배제에 사용할 뿐만 아니라 다양한 연산의 순서도 제공한다.

### 3-1. 세마포 개념과 동작
세마포는 값이 음이 아닌 정수인 플래그 변수이다. 이를 설명하는 가장 유명한 예는 열차의 진행 가능 여부를 나타내는 차단기이다. 차단기가 올라가면 장애물이 있다는 표시이므로 열차는 정지해야한다(자원이 없어 기다리는 상황). 반대로 차단기가 내려가면 장애물이 없으므로 열차는 계속 진행할 수 있다(자원을 사용할 수 있는 자유 상태).

세마포 값은 true나 false로, P와 V 연산과 관련되어 있다. 네덜란드어로 P는 검사(Proberen)를 의미하고, V는 증가(Verhogen)를 의미한다. 그리고 세마포를 의미하는 S는 표준 단위 연산 P와 V로만 접근하는 정수 변수이다. P와 V 연산은 운영체제가 실행하고, 세마포를 인자로 명명한 임의의 프로세스가 요청한 시스템 호출을 하여 다음과 같이 정의한다.
```c
//  P(S)
wait(S) {                   //  S = 1로 초기화
    while S <= 0
        ;                   //  바쁜 대기, S > 0 때까지 대기
    S--;
}

//  V(S)
signal(S) {
    S++;                    //  다른 프로세스의 접근 허용
}
```

P와 V 연산에 있는 세마포 S의 값은 개별적으로 실행하고, 정수 변수와 비슷하지만 모든 변경 연산을 분할 없이 실행해야 한다. 그리고 프로세스가 세마포 값을 수정할 때는 다른 프로세스가 중단할 수 없고, 동일한 세마포 값을 동시에 수정할 수도 없다. 다시 말해, P와 V 연산을 종료할 때까지는 다른 프로세스가 두 연산을 수행하지 않도록 조정해야 한다. 

S에 대한 P의 연산은 S값을 검사하여 양수이면 1을 감소시키는 과정이다. 검사, 인출, 감소, 저장 순서로 구성한다. 그리고 S에 대한 V 연산은 S를 1만큼 증가시키는 과정이다. 인출, 증가, 저장 순서로 구성하고, 교착 상태를 피하려고 단일 머신 사이클에서 단일 동작으로 수행해야 한다. 관례적으로 세마포가 0일 때 lock 또는 사용 중이고, 그렇지 않을 때 양의 값은 세마포를 사용할 수 있다는 의미이다. 물론 세마포는 음의 값을 가질 수 없다.

세마포는 임계 영역을 구현하거나 스케줄링 제약 조건을 시행할 수 있다. 임계 영역은 보통 세마포를 사용하여 1로 초기화한다. 프로세스는 임계 영역에 진입하려고 wait(S)를 호출하여 임의의 다른 프로세스가 대기 조건을 통과하는 것을 방지할 수 있다. 그리고 해당 프로세스가 임계 영역을 종료하면 다음 프로세스가 임계 영역에 진입할 수 있도록 signal(S)를 호출한다. 때에 따라서는 세마포를 1보다 큰 값으로 초기화하면 유용하다. 여러 프로세스가 한 번에 임계 영역에 진입할 수 있기 때문이다. 임계 영역의 데이터를 보호해야 할 때는 문제가 될 수 있지만, 여러 사용자와 생산자 문제처럼 동시 사용이 가능한 자원에서는 유용한 방법이다.

세마포에 적용된 P와 V 연산은 상호배제 개념을 포함하므로 프로세스 n개의 임계 영역 문제를 다루는 데 사용한다. 즉 아래와 같이 P<sub>n</sub> 프로세스 n개가 1로 초기화한 세마포 mutex를 공유할 수 있다.

```c
do {
    wait(mutex);
        //  임계 영역
    signal(mutex);
        //  나머지 영역
} while(1);
```

또 세마포는 동기화하는데 사용할 수 있다. 예를 들어, 명령문 S<sub>1</sub>이 있는 프로세스 P<sub>1</sub>과 명령문 S<sub>2</sub>가 있는 프로세스 P<sub>2</sub>를 수행 중이고, S<sub>1</sub>이 끝난 후에 S<sub>2</sub>를 수행하도록 구현해야 한다고 하자. 아래와 같이 P<sub>1</sub>과 P<sub>2</sub>가 세마포 synch를 공유하고 프로세스 P<sub>1</sub>과 프로세스 P<sub>2</sub>에 각 명령문을 삽입하여 구현할 수 있다. 이 때 세마포 synch를 0으로 초기화하면 프로세스 P<sub>1</sub>이 명령문 S<sub>1</sub>을 실행한 후 signal(synch)를 호출하여 프로세스 P<sub>2</sub>의 S<sub>2</sub>를 수행한다.

```c
//  프로세스 P1
S1;
signal(synch);

//  프로세스 P2
wait(synch);
S2;
```

### 3-2. 세마포의 종류
