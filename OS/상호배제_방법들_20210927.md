[목록](https://github.com/JungInBaek/TIL/blob/main/README.md)

# 상호배제 방법들

## 1. 데커의 알고리즘
네덜란드의 수학자 테오도루스 요제프 데커는 두 프로세스가 서로 통신하려고 공유 메모리를 사용하여 충돌 없이 단일 자원을 공유할 수 있도록 허용하는 데커의 알고리즘(Dekker's algorithm)을 개발했다.

데커의 알고리즘은 두 프로세스가 동시에 임계 영역에 진입하려고 시도하면 순서에 따라 오직 하나만 임계 영역에 들어가도록 허용한다. 데커의 알고리즘에서 각 프로세스는 플래그를 설정할 수 있고, 다른 프로세스를 확인한 후 플래그를 재설정할 수도 있다. 프로세스가 임계 영역에 진입하고 싶으면 플래그를 설정하고 차례를 기다린다. 즉, 임계 영역에 다른 프로세스가 이미 있으면 해당 프로세스를 종료할 때까지 while문에서 순환한다. 여기서는 임계 영역 진입, 두 프로세스간의 순서를 나타내는 turn 변수를 입력했다는 의미로 flag[0] 플래그와 flag[1] 플래그를 사용한다. 그런데 프로세스 2개가 동시에 임계 영역에 진입하도록 플래그를 설정하면 교착 상태가 발생할 수 있다.
다음 데커의 알고리즘을 이용한 것이다.
```c
//  프로세스가 공유하는 데이터 flag[] : 부울(boolean) 배열, turn : 정수
flag[0] = false;
flag[1] = false;
turn = 0;                        //  공유 변수, 0 또는 1

//  프로세스 P0:                 //  프로세스 P0의 임계 영역 진입 절차
flag[0] = true;                 //  P0의 임계 영역 진입 표시
while(flag[1] == true) {        //  P1의 임계 영역 진입 여부 확인
    if(turn == 1) {             //  P1이 진입할 차례가 되면
        flag[0] == false;       //  플래그를 재설정하여 P1에 진입 순서 양보
        while(turn == 1) {      //  turn을 바꿀 때까지 대기
            //  바쁜 대기
        }
        flag[0] = true;         //  P0이 임계 영역에 재진입 시도
    }
}
/* 임계 영역 */;
turn = 1;                       //  P1에 진입 순서 제공
flag[0] = false;                //  P0의 임계 영역 사용 완료 지정
/* 나머지 영역*/;                //  P0이 나머지 영역 수행

//  프로세스 P1
flag[1] = true;
while(flag[0] == true) {
    if(turn == 0) {
        flag[1] == false;
        while(turn == 0) {
            //  바쁜 대기
        }
        flag[1] = true;
    }
}
/* 임계 영역 */;
turn = 0;
flag[1] = false;
/* 나머지 영역 */;
```

다음은 상호배제 문제를 소프트웨어적으로 해결하는 데커의 알고리즘 특징이다.
- 특별한 하드웨어 명령문이 필요 없다.
- 임계 영역 바깥에서 수행 중인 프로세스가 다른 프로세스들이 임계 영역에 들어가려는 것을 막지 않는다.
- 임계 영역에 들어가기를 원하는 프로세서를 무한정 기다리게 하지 않는다.

## 2. TestAndSet(TAS, 테스) 명령어
메모리 영역의 값에 대해 검사와 수정을 원자적으로 수행할 수 있는 하드웨어 명령어 TestAndSet을 이용하여 간단한 방법으로 임계 영역 문제를 해결할 수 있다.
TestAndSet 명령어는 하드웨어에서 명령을 사용하므로 알고리즘이 간단하고, 하나의 메모리 사이클에서 수행하여 생산자, 소비자에서 예로 든 counter 공유 변수를 수정해서 발생하는 경쟁 상황을 해결할 수 있다. 이 알고리즘에는 기계 명령어가 2개 있다. 하나는 원자적 연산 명령어인 TestAndSet이고, 다른 하나는 TestAndSet에 지역변수 lock을 설정하는 명령어이다.

TansAndSet 명령어는 일부 시스템에서 원자 명령어의 하나로, 읽기와 쓰기 모두를 제공한다. 이 명령어는 해당 주소의 값을 읽고 새 값으로 교체하면서 해당 메모리 위치의 이전 값을 돌려준다.

```c
//  target을 검사하고, target 값을 true로 설정
boolean TestAndSet(boolean *target) {
    boolean temp = *target;     //  이전 값 기록
    *target = true;             //  true로 설정
    return temp;                //  값 반환
}
```
TestAndSet명령어

부울 변수 lock을 사용하여 프로세스가 임계 영역에 있으면 1로, 없으면 0으로 설정할 수 있다. 그러므로 기계가 TestAndSet 명령어를 지원할 때는 부울 변수 lock을 false로 초기화하여 상호배제를 구현할 수 있다.

```c
do
{
    while(TestAndSet(&lock))        //  lock을 검사하여 true이면 대기, false이면 임계 영역 진입
        ;                           //  아무것도 하지 않음
        //  임계 영역
    lock = false;                   //  다른 프로세스의 진입 허용 의미로 lock을 false로
        //  나머지 영역
} while(true);
```
lock을 사용한 상호배제

처음에는 lock을 false로 초기화했으므로 처음 실행한 프로세스는 첫 while문을 통과한다. 하지만 TestAndSet 명령어로 lock은 true가 되므로 다른 프로세스가 임계 영역을 실행하려고 해도 while문에서는 아무것도 못하고 대기하게 된다(상호배제 조건 만족). 임계 영역을 다 끝낸 프로세스는 lock을 다시 false로 되돌려서 다른 프로세스도 임계 영역을 실행할 수 있도록 하여 진행 조건을 만족한다. 이 때 프로세스 2개는 문제가 없지만, 여러 프로세스가 대기 중일 때 어떤 프로세스는 무한 대기 상태에 빠질 수 있으므로 한정 대기 조건을 만족한다고 볼 수는 없다.

기계가 TestAndSet 명령어를 지원하면 먼저 boolean wating을 공유 배열 waiting[0 ...... n-1]로 선언한다. 공유 부울 변수 lock은 모든 프로세스에 전역변수로 선언하고 모두 false로 초기화한다. 그런 다음 다음과 같이 선언하여 상호배제를 구현할 수 있다.

```c
boolean waiting[n];
boolean lock = false;
int j;         //   0 ...... n-1
boolean key;
```

```c
do                                      //  프로세스 P1의 진입 영역
{
    waiting[i] = true;
    key = true;
    while(waiting[i] && key)
        key = TestAndSet(&lock);
    waiting[i] = false;
        //  임계 영역
        //  탈출 영역
    j = (i + 1) % n;
    while((j != i && !waiting[j]))      //  대기 중인 프로세스를 찾음
        j = (j + 1) % n;
    if(j == i)                          //  대기 중인 프로세스가 없으면
        lock = false;                   //  다른 프로세스의 진입 허용
    else                                //  대기 프로세스가 있으면 다음 순서로 임계 영역에 진입
        waiting[j] = false;             //  Pj가 임계 영역에 진입할 수 있도록
        //  나머지 영역
} while(true);
```
TestAndSet 명령어를 이용한 상호배제

프로세스 P<sub>i</sub>의 진입 영역에서 waiting[i]가 true이므로 P<sub>i</sub>는 임계 영역에 진입을 시도한다. 처음에 lock을 false로 초기화했다. 그러므로 임계 영역에 들어가는 첫번째 프로세스는 TestAndSet으로 key가 false가 되어 while문을 통과하여 임계 영역을 진행한다. lock은 TestAndSet으로 true가 되므로 key는 계속 true이고, 다른 프로세스는 while문을 통과하지 못한다. 반대로 다른 프로세스가 임계 영역에 있으면 lock은 true가 되어 P<sub>i</sub>는 while(waiting[i] && key) ~ key = TestAndSet(&lock);를 순환할 것이다. P<sub>i</sub>가 임계 영역에 들어가면 waiting[i]는 false로 설정하고 임계 영역으로 진입한다. 여기서 TestAndSet 명령어로 false를 반환하면서 lock이 true로 설정된 것에 주목해야 한다.

P<sub>i</sub>가 임계 영역을 떠날 때는 대기 프로세스 중에서 다음으로 진입할 수 있는 프로세스를 선택해야 한다. 다음으로 차례가 높은 프로세스를 시작한 후 각 프로세스를 검사한다. waiting 배열을 i+1, i+2, ...... , n-1, 0 순서로 조사하여 waiting 값이 true인 첫 번째 프로세스가 임계 영역으로 진입할 다음 프로세스가 된다. waiting 값이 true인 프로세스가 없으면 lock을 해제하고, 다음 프로세스가 P<sub>j</sub>이면 임계 영역에 진입할 수 있도록 P<sub>i</sub>는 waiting[j]를 false로 변경한다.

이 명령어의 주요 기능은 임계 영역의 잠금과 프로세스 대기 상태를 이용하여 프로세스를 차단하는 것이다.

TestAndSet 명령어의 장점과 단점은 다음 표와 같다.

<table>
    <tr>
        <td>장점</td><td>사용자 수준에서 가능하다. <br>- 메인 메모리를 공유하는 다중 프로세서나 단일 프로세서에서 프로세스 수에 관계없이 적용할 수 있다. <br>- lock 변수 수에 상관없이 구현할 수 있다. <br>- 구현이 단순하고 확인이 용이하다. <br>- 다중 임계 영역을 지원한다.</td>
    </tr>
    <tr>
        <td>단점</td><td>● 바쁜 대기 발생 <br>- 프로세서 시간 소모가 크다. <br>- 대기 프로세스는 비생산적, 자원이 소모되는 대기 루프에 남는다. <br>● 기아 상태 발생 : 프로세스가 임계 영역을 떠날 때 프로세스 하나 이상을 대기하는 경우 가능하다. <br>● 교착 상태 발생 : 플래그는 우선순위가 낮은 프로세스가 재설정할 수 있지만, 우선순위가 높은 프로세스가 선점한다. 따라서 우선순위가 낮은 프로세스는 lock을 가지고, 우선순위가 높은 프로세스가 이것을 얻으려고 시도할 때 높은 우선순위 프로세스는 무한정 바쁜 대기가 될 것이다.</td>
    </tr>
</table>

## 3. 세마포
앞서 제시한 상호배제의 해결 방법은 좀 더 복잡한 문제에서는 일반화하기가 어렵다. 또 프로세스가 임계 영역에 진입할 수 없을 때는 바쁜 대기를 하게 되어 프로세스를 낭비한다. 진입 조건을 반복 조사하지 않고 true일 때 프로세스 상태를 확인한다면 프로세서 사이클을 낭비하지 않을 것이다. 다익스트라는 1965년 새로운 동기화 도구인 세마포(semaphore)를 제안하여 이 문제를 해결했다. 세마포는 상호배제에 사용할 뿐만 아니라 다양한 연산의 순서도 제공한다.

### 3-1. 세마포 개념과 동작
세마포는 값이 음이 아닌 정수인 플래그 변수이다. 이를 설명하는 가장 유명한 예는 열차의 진행 가능 여부를 나타내는 차단기이다. 차단기가 올라가면 장애물이 있다는 표시이므로 열차는 정지해야한다(자원이 없어 기다리는 상황). 반대로 차단기가 내려가면 장애물이 없으므로 열차는 계속 진행할 수 있다(자원을 사용할 수 있는 자유 상태).

세마포 값은 true나 false로, P와 V 연산과 관련되어 있다. 네덜란드어로 P는 검사(Proberen)를 의미하고, V는 증가(Verhogen)를 의미한다. 그리고 세마포를 의미하는 S는 표준 단위 연산 P와 V로만 접근하는 정수 변수이다. P와 V 연산은 운영체제가 실행하고, 세마포를 인자로 명명한 임의의 프로세스가 요청한 시스템 호출을 하여 다음과 같이 정의한다.
```c
//  P(S)
wait(S) {                   //  S = 1로 초기화
    while S <= 0
        ;                   //  바쁜 대기, S > 0 때까지 대기
    S--;
}

//  V(S)
signal(S) {
    S++;                    //  다른 프로세스의 접근 허용
}
```

P와 V 연산에 있는 세마포 S의 값은 개별적으로 실행하고, 정수 변수와 비슷하지만 모든 변경 연산을 분할 없이 실행해야 한다. 그리고 프로세스가 세마포 값을 수정할 때는 다른 프로세스가 중단할 수 없고, 동일한 세마포 값을 동시에 수정할 수도 없다. 다시 말해, P와 V 연산을 종료할 때까지는 다른 프로세스가 두 연산을 수행하지 않도록 조정해야 한다. 

S에 대한 P의 연산은 S값을 검사하여 양수이면 1을 감소시키는 과정이다. 검사, 인출, 감소, 저장 순서로 구성한다. 그리고 S에 대한 V 연산은 S를 1만큼 증가시키는 과정이다. 인출, 증가, 저장 순서로 구성하고, 교착 상태를 피하려고 단일 머신 사이클에서 단일 동작으로 수행해야 한다. 관례적으로 세마포가 0일 때 lock 또는 사용 중이고, 그렇지 않을 때 양의 값은 세마포를 사용할 수 있다는 의미이다. 물론 세마포는 음의 값을 가질 수 없다.

세마포는 임계 영역을 구현하거나 스케줄링 제약 조건을 시행할 수 있다. 임계 영역은 보통 세마포를 사용하여 1로 초기화한다. 프로세스는 임계 영역에 진입하려고 wait(S)를 호출하여 임의의 다른 프로세스가 대기 조건을 통과하는 것을 방지할 수 있다. 그리고 해당 프로세스가 임계 영역을 종료하면 다음 프로세스가 임계 영역에 진입할 수 있도록 signal(S)를 호출한다. 때에 따라서는 세마포를 1보다 큰 값으로 초기화하면 유용하다. 여러 프로세스가 한 번에 임계 영역에 진입할 수 있기 때문이다. 임계 영역의 데이터를 보호해야 할 때는 문제가 될 수 있지만, 여러 사용자와 생산자 문제처럼 동시 사용이 가능한 자원에서는 유용한 방법이다.

세마포에 적용된 P와 V 연산은 상호배제 개념을 포함하므로 프로세스 n개의 임계 영역 문제를 다루는 데 사용한다. 즉 아래와 같이 P<sub>n</sub> 프로세스 n개가 1로 초기화한 세마포 mutex를 공유할 수 있다.

```c
do {
    wait(mutex);
        //  임계 영역
    signal(mutex);
        //  나머지 영역
} while(1);
```

또 세마포는 동기화하는데 사용할 수 있다. 예를 들어, 명령문 S<sub>1</sub>이 있는 프로세스 P<sub>1</sub>과 명령문 S<sub>2</sub>가 있는 프로세스 P<sub>2</sub>를 수행 중이고, S<sub>1</sub>이 끝난 후에 S<sub>2</sub>를 수행하도록 구현해야 한다고 하자. 아래와 같이 P<sub>1</sub>과 P<sub>2</sub>가 세마포 synch를 공유하고 프로세스 P<sub>1</sub>과 프로세스 P<sub>2</sub>에 각 명령문을 삽입하여 구현할 수 있다. 이 때 세마포 synch를 0으로 초기화하면 프로세스 P<sub>1</sub>이 명령문 S<sub>1</sub>을 실행한 후 signal(synch)를 호출하여 프로세스 P<sub>2</sub>의 S<sub>2</sub>를 수행한다.

```c
//  프로세스 P1
S1;
signal(synch);

//  프로세스 P2
wait(synch);
S2;
```

### 3-2. 세마포의 종류
세마포에는 계수(counting) 세마포와 이진(binary) 세마포가 있다. 계수 세마포는 생산자, 소비자 문제처럼 상호배제와 조건부 동기화를 해결하려고 설계했고, 이진 세마포는 임계 영역처럼 특별히 상호배제를 해결하려고 설계했다. 

- 이진 세마포
이진 세마포에서는 세마포 S를 상호배제에 사용하고, 1 또는 0으로 초기화하고, P와 V의 연산을 교대로 실행한다.

    - P(S) : S를 검사하여 양수이면 S를 0으로 재설정한 후 진행하고, 아니면 S를 준비 큐로 되돌린다.
    - V(S) : S를 1로 설정하고 준비 큐에 있는 프로세스를 시작한다.

세마포 S를 1로 초기화하면 P연산을 먼저 실행하고, 세마포 S를 0으로 초기화하면 V연산을 먼저 실행한다. S를 1로 초기화하면 P연산을 먼저 실행하고 이어서 V연산을 실행하는 경우이다. 즉, S를 0으로 초기화하기 전에 V연산을 실행할 때 P와 V연산을 모두 차단한다. 이진 세마포는 처음 만들 때 사용 가능 상태이나, 사용 불가능 상태로 초기화할 수 있으므로 0이면 이용할 수 없거나 비었다고 생각할 수 있다. 

- 계수 세마포
계수 세마포는 유한한 자원에 접근하는 것을 제어할 수 있으므로, 여러번 획득하거나 해제할 수 있도록 count를 자원의 사용 허가 값으로 사용한다. 그리고 사용 가능한 자원 수로 초기화하므로, count를 초기의 세마포 수로 초기화한다.

각 프로세스가 자원을 사용하려면 P연산을 수행하고 S(count)를 감소시킨다(S--). 또 프로세스가 자원을 해제할 때는 V연산을 수행하고 S(count)를 증가시킨다(S++).

계수 세마포는 초기 count가 0이면 사용할 수 없는 상태로 생성하고, 0보다 크면 사용 가능한 상태로 생성한다. 이 때 사용 가능한 세마포 수는 count와 동일하다. count가 0이면 모든 자원을 사용한다는 의미이므로, count가 0보다 클 때까지 자원을 사용하려는 모든 프로세스를 차단한다. 따라서 프로세스 하나 이상은 count가 0이 아닐 때까지 계수 세마포에서 계속 접근 권한을 획득할 수 있다. count가 0이면 사용 불가능 상태가 된다. 계수 세마포를 사용 불가능 상태에서 다시 사용 가능 상태로 바꾸려면 모든 프로세스로 해제해야 하는데, 해제 연산은 count++이다. 이진 세마포처럼 계수 세마포도 계수 세마포가 필요한 모든 프로세스가 공유할 수 있는 전역 자원이다.

### 3-3. 세마포의 구현
세마포는 제어된 변수로, P(wait)와 V(signal)의 초기 연산 때만 값이 변할 수 있다. 그리고 이진 세마포는 0과 1만 가진다. 상호배제의 해결과 세마포의 단점은 바쁜 대기 요구로 프로세서 시간을 낭비하는 것이다. 세마포의 wait와 signal연산을 수정하면 바쁜 대기 요구를 극복할 수 있다. 프로세스가 wait연산을 실행하고 세마포 값이 양수가 아니면 프로세스는 대기한다. 이 때 바쁜 대기보다 프로세스 자체를 중단할 수 있다. 프로세스 중단은 세마포와 연관된 준비 큐로 프로세스를 배치하므로 프로세스는 대기 상태로 전환한다. 다음 제어를 넘겨받은 프로세서는 준비 큐에서 다른 프로세스를 선택하여 실행하도록 프로세서 스케줄러에 전송한다. 중단된 프로세스는 다른 프로세스가 signal연산을 실행해야 재시작 할 수 있다. 프로세스는 대기 상태에서 준비 상태로 변경할 때 wakeup연산으로 다시 시작하여 다음 준비 큐에 놓인다. 이를 바탕으로 세마포는 아래와 같이 정의할 수 있다. 각 세마포는 정수 값과 프로세스 열을 갖는다. 프로세스가 세마포를 대기해야 할 때는 이 프로세스를 준비 큐에 추가한다. signal연산은 준비 큐에서 프로세스 하나를 꺼내 그 프로세스를 시작한다.

```c
struct semaphore {
    int count;
    queueType queue;
};

semaphore S;
```
세마포의 구조

그리고 wait와 signal연산은 각각 아래와 같이 정의할 수 있다.

```c
wait(S) {
    S -> count--;
    if(S -> count < 0) {
        add this process to S -> queue;         //  프로세스를 준비 큐에 추가
        block();                                //  프로세스 중단(일시정지)
    }
}
```
wait연산

```c
signal(S) {
    S -> count++;
    if(S -> count <= 0) {
        remove a process P from S -> queue;     //  준비 큐에서 P프로세스를 제거
        wakeup(P);                              //  신호를 보내 프로세스를 실행
    }
}
```
signal연산

이처럼 P와 V연산은 세마포 S를 수정하는데 사용하여 중단과 실행 동기화를 구현한다. block연산은 호출하는 프로세스를 중단하고, wakeup(P)연산은 중단된 프로세스P를 다시 실행한다. wait연산을 처음 수행하는 프로세스는 초깃값 S = 1을 감소시켜 0이 된다. 그러면 if조건은 거짓이 되어 임계 영역을 수행한다. 이후 다른 프로세스가 계속 임계 영역에 진입하려고 P연산을 수행할 때마다 세마포 S값은 감소한다. 따라서 바쁜 대기 세마포에서는 절대 음수일 수 없지만, 여기에 구현된 세마포는 음수 값이 될 수 있다. 세마포 값이 음수이면 S의 실제 값은 세마포에서 기다리는 프로세스 수를 나타내는데, 이는 wait연산에서 감산과 검사 순서를 맞바꾸면서 나타난다.

프로세스 준비 큐는 각 프로세스 제어 블록(PCB)의 링크 필드 정보를 이용하여 쉽게 구현할 수 있다. 각 세마포는 정수 값과 PCB 등 열 포인터를 포함한다. 준비 큐에서 프로세스를 추가, 제거하는 가장 간단한 방법은 선입선출(FIFO) 큐를 사용하는 것이다.

세마포의 주요 특징은 원자(단위)적으로 수행한다는 것이다. 두 프로세스가 동시에 동일한 세마포에서 wait와 signal연산을 할 수 없도록 해야 한다. 이는 임계 영역 문제의 한 예로, 다음 두가지 방법으로 해결할 수 있다.
- 단일 프로세서에서는 wait와 signal연산 수행 중 인터럽트를 금지한다. 
- 다중 프로세서에서는 인터럽트를 금지할 수 없으므로, 하드웨어가 임계 영역 문제에 특별한 명령을 제공하지 않으면 이를 소프트웨어적으로 해결해야 하는데, wait와 signal연산으로는 바쁜 대기를 완전히 제거할 수 없다. 따라서 응용 프로그램의 진입 영역에서 임계 영역까지 바쁜 대기를 제거해야 한다. 결국 바쁜 대기의 시기를 이동해야 하는 것이다.

세마포에서는 wait나 signal연산을 생략하면 상호배제 문제가 발생하고, wait연산 때문에 대기하는 프로세스들이 교착 상태에 빠질 수 있다는 취약점이 발생한다. wait연산을 시작하여 세마포를 사용하는 동안에는 프로세스가 다른 경로를 선택할 수 없기 때문이다. 프로세스는 한 번에 세마포 하나만 대기할 수 있어 자원을 할당하는 상황에서 두 프로세스가 각각 자원을 하나씩 보유하고, 상대방의 자원을 사용하려고 대기하는 교착 상태를 가져올 수도 있는 것이다.