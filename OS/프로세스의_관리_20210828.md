[목록](https://github.com/JungInBaek/TIL/blob/main/README.md)

# 프로세스의 관리


## 1. 프로세스의 구조
운영체제는 프로세스의 생성, 종료, 제거, 중단(서스펜드, suspend), 우선순위 변경, 대기, 문맥 교환 등 다양한 작업을 수행할 수 있다. 이는 먼저 프로세스의 구조를 알아야 이해할 수 있다.

프로세스는 실행 중에 프로세스 생성 시스템 호출을 이용하여 새로운 프로세스를 생성할 수 있다. 이 때 프로세스 생성 순서를 저장하고 부모-자식 관계를 유지하여 계층적으로 생성한다. 프로세스를 새로 생성하는 프로세스는 부모 프로세스(parent process)이고, 생성되는 프로세스는 자식 프로세스(child process) 또는 서브 프로세스(subprocess)이다. 부모 프로세스는 자식 프로세스를 생성하는 과정을 반복하면서 계층 구조를 형성한다.


## 2. 프로세스의 생성
운영체제나 응용 프로그램에서 요청을 받아 프로세스를 생성하면, 운영체제는 해당 프로세스에서 프로세스 제어 블록을 만들어 주소 공간을 할당한다. 일괄 처리 환경에서는 준비 큐에 작업이 도착할 때 프로세스를 생성하고, 대화형 환경에서는 새로운 사용자가 로그온(log-on)할 때 프로세스를 생성한다.

예를 들어, 사용자 요청에 따라 프린터를 구동하는 프로세스를 생성하면 해당 프로세스의 식별자를 결정하고, 우선 순위를 부여하고, 프로세스 제어 블록을 생성(할당된 자원, 자원 리스트 등 정보 기록)하고, 초기 자원을 할당한 후 준비 상태가 되어 준비 리스트의 마지막에 위치한다. 다음은 이런 프로세스를 생성할 때 필요한 세부 작업을 단계별로 정리한 것이다.

① 새로운 프로세스에 프로세스 식별자를 할당한다.  
② 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간을 할당한다.  
③ 프로세스 제어 블록을 초기화한다. 프로세스 상태, 프로그램 카운터 등 초기화, 자원 요청, 프로세스 제어 정보(우선순위) 등을 포함한다.
④ 링크를 건다(해당 큐에 삽입한다).

자식 프로세스는 운영체제에서 직접 필요한 자원을 얻거나 부모 프로세스의 자원을 일부 사용할 수 있다. 이 때 부모 프로세스는 자식 프로세스가 사용하는 자원을 제한해서 특정 프로세스가 자식 프로세스를 너무 많이 생성하여 시스템에 부담을 주는 것을 막을 수 있다.

프로세스를 생성할 때는 이런 자원 외에도 일부 초기화 데이터를 부모 프로세스에서 자식 프로세스로 전달하기도 한다.

프로세스가 새로운 프로세스를 생성할 때 다음 두 가지 실행이 발생할 수 있다.
- 부모 프로세스와 자식 프로세스를 동시에 실행한다.
- 부모 프로세스는 자식 프로세스를 모두 종료할 때까지 기다린다.

fork 명령어를 사용하는 경우는 크게 두 가지이다. 첫번째 경우는 부모와 동일한 자식을 복제하는 것이고, 두번째 경우는 fork 명령어를 호출한 후 exec 명령어를 연달아 호출하여 자식 프로세스의 주소 공간을 별도 프로그램 주소 공간으로 덮어쓰는 것이다.


## 3. 프로세스의 종료
프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스의 삭제를 요청한다. 일괄 처리 환경에서는 작업 종료를 의미하는 신호로 인터럽트를 발생하거나 시스템 호출로 중단 명령을 전달하여 프로세스를 종료한다. 대화형 환경에서는 사용자가 로그오프(log-off)하거나 터미널을 닫으면 프로세스를 종료한다. 이외에도 오류로 프로세스를 종료할 수 있다.

abort 명령어로도 프로세스를 종료할 수 있다. abort 명령어는 종료할 프로세스의 부모 프로세스만 호출하는데, 부모가 아닌 다른 프로세스가 임의로 해당 프로세스를 중단할 수 없기 때문이다. 그리고 자식 프로세스는 종료할 때 자신의 식별자를 부모 프로세스에 전달한다.

부모 프로세스는 다음 상황에서 자식 프로세스를 종료할 수 있다. 보통 부모 프로세스를 종료하면 자식 프로세스는 필요치 않으므로 운영체제가 자식 프로세스도 종료하는데, 이를 연속 종료라고 한다.
- 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때
- 자식 프로세스에 할당한 작업이 더는 없을 때

유닉스에서는 exit 명령어로 프로세스를 종료하고, 부모 프로세스는 wait 명령어를 사용하여 자식 프로세스의 종료를 기다린다. wait 명령어는 종료한 자식 프로세스의 식별자를 부모 프로세스에 돌려주므로 어던 자식 프로세스를 종료했는지 알려 준다.

프로세스는 다양한 이유로 종료할 수 있는데, 다음은 몇 가지 예이다.
- 정상 종료 : 프로세스가 운영체제의 서비스를 호출할 때
- 시간 초과 : 프로세스가 명시된 전체 시간을 초과하여 실행하거나 명시된 시간을 초과하면서 어던 이벤트 발생을 기다릴 때
- 실패 : 파일 검색 실패, 입출력이 명시된 횟수를 초과하여 실패할 때
- 산술 오류, 보호 오류, 데이터 오류 등
- 메모리 부족, 액세스 위반 등


## 4. 프로세스의 제거
프로세스 제거는 프로세스를 파괴하는 것이다. 프로세스를 제거하면 사용하던 자원을 시스템에 돌려주고, 해당 프로세스는 시스템 리스트나 테이블에서 사라져 프로세스 제어 블록을 회수한다. 하지만 프로그램은 여전히 디스크에 저장한다. 그리고 자식 프로세스는 부모 프로세스를 제거하면 자동으로 제거된다.


## 5. 프로세스의 중단과 재시작
시스템의 유휴시간 문제는 프로세스 중단(일시정지) 상태를 이용하여 해결할 수 있다. 운영체제는 새로운 프로세스를 생성하여 실행하거나 실행 중인 프로세스를 중단했다가 다시 실행하여 사용할 수 있다. 실행에서 대기가 아닌 중단 상태를 추가하면 특정 이벤트의 발생을 기다리면서 대기 상태가 된다. 그러면 해당 이벤트가 발생할 때 즉시 실행 상태로 바꿀 수 있는 이점이 있다.

프로세스를 중단한 원인을 제거하여 다시 실행하는 것을 재시작이라고 한다.  
프로세스 중단과 재시작은 시스템 부하를 조절하는데 상당히 중요하고, 다음 상황에서 주로 발생한다.
- 시스템에 장애가 발생하면 실행 중인 프로세스는 잠시 중단했다가 시스템이 기능을 회복할 때 다시 재시작할 수 있다.
- 프로세스에 의심스러운 부분이 있으면 실행 중인 프로세스를 중단하여 확인한 후 재시작하거나 종료할 수 있다.
- 처리할 작업이 너무 많아 시스템에 부담이 되면(너무 많은 적재) 프로세스 몇 개를 중단했다가 시스템이 정상 상태로 다시 돌아왔을 때 재시작할 수 있다.

중단은 아주 중요한 작업이다. 장시간 중단할 때는 해당 프로세스에 할당된 자원을 다시 돌려주어야 하는데, 자원의 성질에 따라서 돌려줄 자원을 결정한다. 중단된 대기 상태는 프로세스가 보조 메모리에 있고 이벤트를 대기 중인 상태이다. 중단된 준비 상태는 프로세스가 보조 메모리에 있지만 즉시 메인 메모리로 적재하여 실행할 수 있는 상태이다. 물론 중단한 프로세스는 중단한 지점부터 다시 시작한다.


## 6. 프로세스의 우선순위 변경
프로세스 스케줄러는 프로세스 제어 블록에 있는 우선순위를 이용하여 준비 리스트의 프로세스를 처리한다. 준비 리스트의 프로세스는 프로세서 중심 프로세스와 입출력 중심 프로세스로 구분할 수 있다. 입출력 중심 프로세스는 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스에 높은 우선순위를 부여하고, 속도가 빠른 디스크 입출력 프로세스에는 낮은 우선순위를 부여한다. 이 때 우선순위가 낮은 프로세스에는 시간을 많이 할당하고, 우선순위가 높은 프로세스에는 시간을 저게 할당한다. 따라서 입출력 중심 프로세스는 프로세서를 짧게 자주 사용하도록 하고, 프로세서 중심 프로세스는 프로세서를 길게 사용하되 사용 횟수를 줄여서 균형을 유지할 수 있다.


## 7. 프로세스의 문맥 교환
현재 실행하는 프로세스와 별도로 외부에서 이벤트가 일어나면 인터럽트가 발생한다. 보통 인터럽트가 발생하면 인터럽트 처리 루틴으로 제어가 넘어간 후에도 시스템 관리와 관련된 기본 작업을 하고는 인터럽트 유형에 따라 관련 루틴으로 분기한다.
- 입출력 인터럽트 : 입출력 동작이 발생했음을 확인하고 이벤트를 기다리는 프로세스를 준비 상태로 바꾼 후 실행할 프로세스를 결정한다.
- 클록 인터럽트 : 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 바꾸고, 다른 프로세스를 실행 상태로 바꾼다.

실행 중인 프로세스에 인터럽트가 발생하면 운영체제가 다른 프로세스를 실행 상태로 바꾸고 제어를 넘겨주어 프로세스 문맥 교환이 일어난다. 인터럽트는 인터럽트 처리 루틴을 실행한 후 현재 실행 중인 프로세스를 재실행할 수 있으므로 인터럽트가 곧 프로세스 문맥 교환으로 발전하지는 않는다. 반면에 트랩(trap)은 부적절한 파일 접근이나 현재 실행중인 프로세스 오류나 예외 상황으로 발생할 수 있다. 시스템에 치명적인 오류인지 판단하여 치명적이면 프로세스를 종료하고는 교환한다.

대개 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하여 프로세스를 교환하는데, 이런 일련의 과정을 문맥 교환(context switching)이라고 한다. 문맥 교환에서는 오버헤드가 발생하느데, 이는 메모리 속도, 레지스터 수, 특수 명령어의 유무에 따라 다르다.  그리고 문맥 교환은 프로세스가 '준비 -> 실행' 상태로 바뀌거나 '실행 -> 준비' 또는 '실행 -> 대기' 상태로 바뀔 때 발생한다.

문맥 교환은 시간 비용이 들어가는 오버헤드이고, 이 오버헤드는 메모리 속도, 레지스터 수, 특수 명령어의 유무에 따라 시스템마다 다르다. 그래서 운영체제를 설계할 때 불필요한 문맥 교환을 줄이는 것을 주요 목표로 정한다.

문맥 교환은 레지스터 문맥 교환, 작업 문맥 교환, 스레드 문맥 교환, 프로세스 문맥 교환이 가능하다. 프로세스와 운영체제가 문맥의 구성 여부를 결정하므로 운영체제를 설계할 때 주요 관심사는 가능한 한 불필요한 문맥 교환을 줄이는 것이다. 운영체제는 스레드를 이용하여 문맥 교환을 효율적으로 처리할 수 있다.