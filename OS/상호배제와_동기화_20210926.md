[목록](https://github.com/JungInBaek/TIL/blob/main/README.md)

# 1. 상호배제의 개념
상호배제는 병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법이다. 

읽기 연산은 공유 데이터에 동싱 접근해도 문제가 발생하지 않는다. 하지만 변수나 파일은 프로세스별로 하나씩 차례로 읽거나 쓰도록 해야 하는데, 공유 자원을 동시에 사용하지 못하게 실행을 제어하는 방법을 동기화라고 한다. 동기화로 상호배제를 보장할 수는 있지만, 이 과정에서 교착 상태와 기아 상태가 발생할 수 있다.

상호배제는 프로세스가 수정할 수 있는 공유 데이터에 접근할 때만 적용하고, 단순 읽기 등을 할 때는 동시에 수행하도록 허용해야 한다. 프로세스가 다른 프로세스와 충돌하지 않는 연산을 할 때는 프로세스를 동시에 수행하도록 허용해야 하므로, 다음 네 가지 조건을 만족해야 한다.
- 두 프로세스는 동시에 공유 자원에 진입할 수 없다.
- 프로세스의 속도나 프로세서 수에 영향을 받지 않는다.
- 공유 자원을 사용하는 프로세스만 다른 프로세스를 차단할 수 있다.
- 프로세스가 공유 자원을 사용하려고 너무 오래 기다려서는 안된다.

프로세스가 어떤 자원을 사용할 때 다른 프로세스가 해당 자원을 사용하지 못하도록 제어하는 능력에 따라 프로세스 동기화의 성공이 결정된다. 그러므로 경쟁 관계에 있는 프로세스들은 상호배제가 필요하다.

# 2. 임계 영역
임계 영역에는 다수의 프로세스가 접근할 수 있지만, 어느 한 순간에는 프로세스 하나만 사용할 수 있다. 그러므로 어떤 프로세스가 임계 영역에 들어가면 다른 프로세스는 임계 영역으로 진입할 수 없어야 한다. 임계 영역은 실행 구간에 해당하므로 임계 영역에서는 작업을 빠르게 수행하고, 특정 프로세스가 임계 영역에 오래 머물거나 무한 루프 등에 빠지지 않도록 관리해야 한다.

임계 영역에 다른 프로세스가 있으면 이 프로세스는 다른 프로세스가 임계 영역에 들어가지 못하게 진입 상호배제를 수행해야 한다. 또 임계 영역에서 나오는 프로세스는 탈출 상호배제를 수행하여 다른 프로세스가 임계 영역에 들어갈 수 있도록 해야 한다.

임계 영역은 다음 세 가지 조건을 만족해야 한다.
- 상호배제 : 어떤 프로세스가 임계 영역에서 작업 중이면 다른 프로세스는 임계 영역으로 들어갈 수 없다.
- 진행 : 임계 영역에 프로세스가 없는 상태에서 여러 프로세스가 들어가려고 할 때는 어떤 프로세스가 들어갈지 적절히 결정해야 한다.
- 한정 대기 : 다른 프로세스가 임계 영역을 무한정 기다리는 상황을 방지하려면 임계 영역에 한번 들어갔던 프로세스는 다음에 임계 영역에 다시 들어갈 때 제한을 둔다.

# 3. 생산자, 소비자 문제와 상호배제를 해결하는 초기의 시도
생산자. 소비자 문제는 운영체제에서 비동기적으로 수행하는 모델로, 생산자 프로세스가 생산한 정보를 소비자 프로세스가 소비하는 형태이다. 생산자는 소비자에게 데이터를 전송할 때, 데이터를 소비자가 받을 준비가 되면 데이터를 전송하고 소비자가 계속 처리하지 못하면 대기해야 한다. 이 때 생산자와 소비자가 불필요하게 공회전하지 않도록 데이터를 전송하는 방법이 필요한데, 이는 임시 기억장소인 버퍼를 도입하여 해결할 수 있다.

생산자가 이미 가득 찬 버퍼에 더 채우려 하거나 소비자가 빈 버퍼에서 데이터를 꺼내려고 하면 문제가 발생한다. 생산자는 버퍼가 가득 찰 때 데이터를 더 생산하지 않고 기다려야 하고, 소비자는 버퍼가 빌 때 소비하지 않고 기다려야 하므로 생산자와 소비자는 동기화를 해야 한다. 이를 버퍼가 무한한 경우와 유한한 경우로 나눠볼 수 있다.

무한 버퍼일 때는 생산자와 소비자가 독립적으로 알고리즘을 수행하도록 하여 버퍼를 잘 활용할 수 있고, 유한 버퍼에서는 논리적 포인터 in과 out 2개로 버퍼를 순환 배열로 구현하여 해결할 수 있다.

버퍼를 프로그램으로 구현해 보자. 여기서 in과 out은 0으로 초기화하고 버퍼는 buffer[BUFFER_SIZE] 정수 배열로 선언하면, 버퍼에 n-1개만 채울 수 있다. 이 결점은 counter 변수를 추가한 후 0으로 초기화하여 보완할 수 있다. 그리고 counter는 원소를 추가할 때마다 1씩 증가시키고, 삭제할 때마다 1씩 감소시킨다.

```c
#define BUFFER_SIZE 10      //  버퍼 크기
typeof struct {
    DATA data;
} item;
item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
int counter = 0;
```
공유 데이터 선언

while 문으로 조건이 거짓일 때까지 반복하여 검사한다. 생산자 프로세스는 생산하는 새로운 원소를 지역변수 nextProduced에 저장하고, 소비자 프로세스는 소비하는 원소를 지역변수 nextConsumed에 저장하여 각 프로세스를 다음과 같이 구현할 수 있다.

```c
item nextProduced;

while(true) {
    //  버퍼가 가득 차 아무 일도 하지 않음
    while(counter == BUFFER_SIZE);
    buffer[in] = nextProduced;
    in = (in + 1) % BUFFER_SIZE;
    counter++;
}
```
생산자 프로세스

```c
item nextConsumed;

while(true) {
    //  버퍼가 비어 아무 일도 하지 않음
    while(counter == 0);
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    counter--;
}
```
소비자 프로세스

두 코드를 동시에 수행하면 기능을 다르게 동작할 수 있다. 예를 들어, counter = 5일 때, counter++와 counter--를 동시에 수행하여 counter 값이 4, 5, 6이 될 수 있는 것이다. 반면에 두 코드를 따로 정상적으로 수행하면 counter 값은 5가 된다. counter 값이 맞는지는 아래와 같이 기계어로 작성하여 확인할 수 있다. 여기서 register<sub>1</sub>, register<sub>2</sub>는 지역 레지스터이다.

register<sub>1</sub> = counter;
register<sub>1</sub> = register<sub>1</sub> + 1;
counter = register<sub>1</sub>;
```
counter++ 기계어
```

register<sub>2</sub> = counter;
register<sub>2</sub> = register<sub>2</sub> - 1;
counter = register<sub>2</sub>;
```
counter-- 기계어
```

두 코드를 동시에 수행한다는 것은 이 기계어들을 임의의 순서로 겹쳐 실행하는 것과 같다.

T<sub>1</sub> : 생산자가 register<sub>1</sub> = counter 수행(register<sub>1</sub> = 5)
T<sub>2</sub> : 생산자가 register<sub>1</sub> = register<sub>1</sub> + 1 수행(register<sub>1</sub> = 6)
T<sub>3</sub> : 소비자가 register<sub>2</sub> = counter 수행(register<sub>2</sub> = 5)
T<sub>4</sub> : 소비자가 register<sub>2</sub> = register<sub>2</sub> - 1 수행(register<sub>2</sub> = 4)
T<sub>5</sub> : 생산자가 counter = register<sub>1</sub> 수행(counter = 6)
T<sub>6</sub> : 소비자가 counter = register<sub>2</sub> 수행(counter = 4)
```
생산자와 소비자의 동시 수행 예
```

이처럼 여러 프로세스가 동시에 공유 데이터에 접근할 때 접근 순서에 따라 실행 결과가 달라지는 상황에 놓인 프로세스들을 경쟁 상태(race condition)에 있다고 한다. 이 때는 공유 데이터에 마지막으로 남는 데이터의 결과를 보장할 수 없는 상황이다. 장치나 시스템이 둘 이상의 연산을 동시에 실행할 때, 어느 프로세스를 마지막으로 수행한 후 결과를 저장했느냐에 따라 오류가 발생한다. 그러므로 적절한순서에 따라 수행해야 한다. 읽기와 쓰기 명령을 거의 동시에 실행해야 한다면, 기본적으로 읽기 명령을 먼저 수행하고 다음에 쓰기 명령을 수행하는 접근 순서화가 필요하다. 경쟁 상태를 예방하려면 병행 프로세스들을 동기화해야 하는데, 이는 임계 영역을 이용한 상호배제로 구현할 수 있다. 즉, 공유 변수 counter를 한순간에 프로세스 하나만 조작할 수 있도록 해야하는 임계 영역과 counter 연산하는 부분을 임계 영역으로 설정하여 상호배제하는 방법으로 해결할 수 있다.