[목록](https://github.com/JungInBaek/TIL/blob/main/README.md)

# 프로세스의 개념과 상태 변화


## 1. 프로세스의 개념
다중 프로그래밍 환경에서는 여러 프로그램을 메모리에 적재하여 병행 실항할 수 있어 컴퓨터의 효율을 높일 수 있다. 병행 실행하는 프로그램들은 컴퓨터 자원을 공유하므로 이를 제어하는 방법이 필요한데, 이 과정에서 프로세스가 등장한 것이다.

프로세스는 다음과 같이 다양하게 정의할 수 있다.
- 실행 중인 프로그램
- 비동기적(asynchronous) 행위
- 실행 중인 프로시저
- 실행 중인 프로시저의 제어 추적
- 운영체제에 들어 있는 프로세스 제어 블록(PCB)
- 프로세서에 할당하여 실행할 수 있는 개체 디스패치(dispatch)가 가능한 대상

이 중 가장 일반적인 프로세스 정의는 '실행 중인 프로그램'이다. 프로그램이 실행 중이라는 의미는 디스크에 있던 프로그램을 메모리에 적재하여 운영체제의 제어를 받는 상태가 되었다는 것이다. 이는 자신만의 메모리 영역(주소 공간)이 있음을 의미한다. 프로세스는 프로그램 실행의 인스턴스도 된다. 따라서 웹 브라우저 창을 한 개 열면 프로세스 한 개를 생성하고, 웹 브라우저 창을 2개 열면 프로세스 2개를 생성한다.

프로세스가 실행 중인 프로그램이 되려면 프로세서 점유시간, 메모리, 파일, 입출력장치 같은 자원이 필요하다. 그리고 프로세스는 현재의 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동(레지스터 내용)도 포함한다.

프로그램은 컴파일한 코드와 초기화 전역벼수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 정적인 개체이다. 프로세스는 스택, 힙 등과 같이 메모리 구조를 이루고, 프로그램 카운터나 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어 있는 동적인 개체이다.

- 스택 : 스택(stack)은 데이터를 일시적으로 저장하는 영역이다. 지역변수에 사용하고, 변수가 범위 밖으로 이동하면 공간을 해제한다. 호출한 함수의 반환 주소, 반환 값, 매개변수 등에 사용하고, 함수를 호출할 수록 커지고 반환하면 줄어든다. 보통 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터를 만나면 메모리가 소진되었다는 의미이다.

- 힙 : 힙(heap)은 코드 영역과는 별도로 유지되는 자유 영역이다. 동적으로 메모리를 할당하려고 프로그램 실행 중 시스템 호출을 사용했다가 해제하는 방법으로 활용한다. 프로세스의 공유 라이브러리와 동적으로 적재된 모듈이 서로 공유하는데, 동적 메모리 할당이 발생하면 보통 위쪽으로 커진다.

- 데이터 : 데이터는 프로그램의 가상 주소 공간이다. 전역변수나 정적변수를 저장하거나 할당하고 실행하기 전에 초기화한다. 그런데 변수 값은 실행 시간에 변경할 수 있어 읽기 전용 영역은 아니지만 읽기 전용 영역이나 읽기와 쓰기 영역으로 초기화할 수 있다. 정적변수는 0으로 초기화하거나 초기화하지 않아도 된다. 초기화하지 않은 데이터는 데이터 영역의 끝에서 시작한다.

- 코드 : 코드는 실행 명령을 포함하는 메모리이거나 목적 파일에 있는 프로그램 영역이다. 프로세스로 변경할 수 없고, 읽기 전용이므로 프로그램이 코드 영역을 침범하여 쓰기를 시도하면 오류가 발생해서 프로그램을 종료한다.

스택과 힙 사이는 서브루틴을 실행하는 영역으로, 운영체제로 매핑되지 않는다. 데이터베이스, 문서 편집기처럼 여러 사용자가 메모리에 있는 동일한 사본을 공유할 수 있는 프로그램을 재진입 프로그램이라고 한다. 프로세스 2개가 동일한 문서 편집기를 사용하고 데이터 영역이 같더라도 스택 영역은 서로 달라 별개의 프로세스로 인식한다.

사용자 관점에서 프로세스는 주소 공간을 가지고 실행하는 프로그램이고, 시스템 관점에서 프로세스는 실행 중인 프로그램이다. 실행 순서를 결정하는 스케줄러는 디스크에 저장된 프로그램에 프로세서를 할당해서 장치나 메모리 같은 파일 자원을 참조한다. 그리고 프로세스를 지원하고 협력하여 교착 상태, 보호, 동기화 같은 정보를 교환한다.

프로세스는 수행하는 역할에 따라 시스템(커널) 프로세스와 사용자 프로세스로 구분하고, 병행 수행 방법에 따라 독립 프로세스와 협력 프로세스로 구분한다.

|구분|종류|설명|
|----------|----------|----------|
|역할|시스템(커널) 프로세스|모든 시스템 메모리와 프로세서의 명령어에 액세스할 수 있는 프로세스이다. 프로세스 실행 순서를 제어하거나 다른 사용자 및 커널(운영체제) 영역을 침범하지 못하게 감시하고, 사용자 프로세스를 생성하는 기능을 한다.|
|역할|사용자프로세스|사용자 코드를 수행하는 프로세스이다.|
|병행 수행 방법|독립 프로세스|다른 프로세스에 영향을 주지 않거나 다른 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스이다.|
|병행 수행 방법|협력 프로세스|다른 프로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행 프로세스이다.|


## 2. 프로세스의 상태 변화와 상태 정보
운영체제는 프로세스의 실행을 제어한다. 그리고 프로세스는 실행하면서 상태가 변하므로 운영체제는 프로세스 제어에 필요한 상태를 점검하고 프로세스를 제어한다.

### 2-1. 프로세스의 상태 변화
프로세스의 상태는 크게 실행 상태와 비실행 상태로 구분할 수 있다. 운영체제가 프로세스를 생성하면 비실행 상태로 초기화해서 실행을 기다린다. 실행 중인 프로세스를 종료하거나 인터럽트가 발생하면 비실행 프로세스 중에서 선택한 프로세스를 실행 상태로 바꾼다(디스패치). 이 때 인터럽트된 프로세스는 비실행 상태가 된다. 실행 중인 프로세스는 새로운 자원을 할당받으려고 프로세서를 기다리는 비실행 상태로 바뀌기도 한다.

프로세스의 실행과 비실행 상태는 준비, 실행, 대기(보류)로 더 세분화할 수 있다. 운영체제의 종류에 따라 프로세스의 상태를 다르게 표현하기도 하지만, 어느 한순간 대부분의 프로세스가 준비나 대기 상태로 바뀌면서 하나만 실행 상태가 된다는 점이 중요하다.

프로세스는 시스템에서 준비, 실행, 대기 상태로 바뀌면서 실행하고 종료하는데, 시스템을 떠날 때까지 이 과정을 반복한다. 프로세스의 상태 변화는 운영체제가 작업 스케줄러와 프로세스 스케줄러와 같은 프로세서 스케줄러를 이용하여 관리한다.

실행 상태의 프로세스가 프로세설르 자발적으로 반환하기 전에 할당된 시간이 지나면 이 프로세스는 준비 상태가 된다. 그리고 프로세스를 실행하다 입출력 명령(또는 시간이 많이 필요한 비슷한 요청)이 발생하면 대기 상태가 된다. 대기 상태인 프로세스는 대기 원인을 제거하면 준비 상태로 바뀌고, 디스패처(dispatcher)가 준비 상태인 프로세스에 프로세서를 할당하면 다시 실행 상태로 바뀐다. 여기서 디스패처는 스케줄러가 선택한 프로세스에 프로세서를 할당하는 모듈이다.

프로세스의 상태별 변화는 다음 표와 같다. 이 중 프로세스 스스로 하는 것은 대기뿐이고, 나머지는 외부 조건으로 발생한다.
|상태 변화|표기 방법|
|-----|------|
|① 준비 -> 실행|dispatch(프로세스 이름)|
|② 실행 -> 준비|timeout(프로세스 이름)|
|③ 실행 -> 대기(보류)|block(프로세스 이름)|
|④ 대기(보류) -> 준비|wakeup(프로세스 이름)|

#### ① 준비 -> 실행
준비 큐 맨 앞에 있던 프로세스가 프로세서를 점유하는 것을 디스패치라고 한다. 다중 프로그래밍 운영체제에서는 실행 상태인 프로세스가 할당된 시간만큼만 프로세서를 사용하도록 하여 특정 프로세스가 프로세서를 계속 독점하는 것을 방지한다.

#### ② 실행 -> 준비
운영체제는 실행 상태의 프로세스가 프로세서를 계속 독점하지 않도록 인터럽트 클록(interrupt clock)을 두어 특정 프로세스가 할당된 시간 동안만 프로세서를 점유하게 한다. 프로세스가 타임아웃되어도 프로세서를 반환하지 않으면 클록이 인터럽트를 발생시켜 운영체제에 프로세서 제어권을 부여하는 것이다. 그러면 실행 상태의 프로세스는 준비 상태가 되고, 준비 리스트의 첫번째 프로세스가 실행 상태가 된다.

#### ③ 실행 -> 대기(보류)
할당된 시간 이전에 실행 상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원 요청 등의 문제로 프로세서를 스스로 양도하면 대기 상태가 된다.

#### ④ 대기(보류) -> 준비
프로세스는 입출력 작업이 끝나면 깨움(wake up)으로 대기에서 준비 상태가 된다.


### 2-2. 프로세스 제어 블록
운영체제가 프로세스를 제어할 때 필요한 프로세스 상태 정보는 프로세스 제어 블록에 저장된다. 프로세스 제어 블록(PCB, Process Control Block)은 특정 프로세스 정보를 저장하는 데이터 블록이나 레코드로, 작업 제어 블록(TCB, Task Control Block)이라고도 한다.

프로세스가 생성되면 메모리에 프로세스 제어 블록을 생성하고, 프로세스가 실행을 종료하면 해당 프로세스 제어 블록도 삭제된다. 프로세스 제어 블록에는 아래와 같은 정보가 들어있는데, 운영체제의 모든 모듈이 이 정보를 읽고 수정할 수 있다.

- 프로세스 식별자 : 각 프로세스의 고유 식별자(숫자, 색인 항목)
- 프로세스 상태 : 생성, 준비, 실행, 대기, 중단 등 상태 표시
- 프로그램 카운터 : 프로세스를 실행하는 다음 명령어의 주소 표시
- 레지스터 저장 영역 : 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터, 조건 코드 등 정보로, 컴퓨터 구조에 따라 수나 형태가 다르다. 인터럽트가 발생하면 프로그램 카운터와 함께 저장하여 재실행할 때 원래대로 복귀할 수 있게 한다.
- 프로세서 스케줄링 정보 : 프로세스의 우선순위, 스케줄링 큐의 포인터, 기타 스케줄 매개변수
- 계정 정보 : 프로세서 사용 시간, 실제 사용 시간, 사용 상한 시간, 계정 번호, 작업이나 프로세스 번호 등
- 입출력 상태 정보, 메모리 관리 정보 등 : 
  - 특별한 입출력 요구 프로세스에 할당된 입출력장치, 열린 파일 리스트 등
  - 운영체제가 사용하는 메모리 시스템에 따라 상한, 하한 레지스터(경계 레지스터), 페이지 테이블이나 세그먼트 테이블 값 등

### 2-3. 프로세스의 문맥 교환
인터럽트나 시스템 호출 등으로 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것을 프로세스 문맥 교환이라고 한다. 프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용을 나중에 사용할 수 있도록 저장한다.